一 、IT 伦理与道德
=
## —— AI智能技术引发的伦理及其它问题
![](https://github.com/yangzhanp/yangzhanp----homework/blob/gh-pages/images/u%3D691116086%2C2376847174%26fm%3D26%26gp%3D0.jpg)
---
### 中国发展研究基金会发布报告——《未来基石——人工智能的社会角色与伦理》。针对人工智能伦理问题，报告在提出一系列建议的同时，也希望推动问题的充分讨论。——【经济日报】
---
#### 1. AI的基本介绍
> 人工智能（Artificial Intelligence），英文缩写为AI。它是研究、开发用于模拟、延伸和扩展人的智能的理论、方法、技术及应用系统的一门新的技术科学。——来自【百度百科】.

#### 2. AI所可能引发的安全问题
> 人工智能还在研究中，但有学者认为让计算机拥有智商是很危险的，它可能会反抗人类。这种隐患也在多部电影中发生过(例如说,I ROBOT),其主要的关键是允不允许机器拥有自主意识的产生与
延续，如果使机器拥有自主意识，则意味着机器具有与人同等或类似的创造性，自我保护意识，情感和自发行为。

![](https://github.com/yangzhanp/yangzhanp----homework/blob/gh-pages/images/u%3D1298893760%2C4208482649%26fm%3D26%26gp%3D0.jpg)

#### 3. 从人文视角来看，人工智能带来了一些有可能撼动社会基础的根本性问题

> 中国发展研究基金会副理事长兼秘书长卢迈表示，人工智能发展将进一步释放社会活力，中国应积极拥抱人工智能，充分利用好它对生产力的解放效应。但是，把握机遇的前提是了解并预防风险，
> 这需要我们在伦理学和社会治理上下功夫。中国发展研究基金会秘书长助理、研究一部主任俞建拖认为，社会应该正视人工智能带来的挑战，并超越纯技术和经济的视角，从社会和人文视角去探讨人
> 工智能带来的影响。随着人工智能的不断发展，我们对于人的理解越来越物化和去意义化，人和机器的边界越来越模糊，我们需要思考这种边界模糊的后果。我们该如何对待机器和自身的关系？人
> 和机器应该整合吗？如果人对快乐和痛苦的感受可以通过其他物理和化学手段来满足，那么，人还有参与社会互动的需要和动力吗？

#### 4. 人工智能还带来了新的社会权力结构问题

> 借助人工智能，企业可以赋予每个用户大量的数据标签，并基于这些标签了解人的偏好和行为，甚至超过用户对自己的了解，这是巨大的权利不对称。

#### 5. 人工智能可能会造成偏见强化

> 在社交媒体中，人工智能将观点相近的人相互推荐，新闻推送也常常存在路径依赖。当人们的信息来源越来越依赖于智能机器，偏见会在这种同化和路径依赖中被强化。

#### 6. 由于人工智能处理事件新型的搞笑性，使得信息繁杂冗长，反而为人类的选择和学习邢家了瓶颈

> 如果人参与社会互动的次数和范围缩小，而人工智能越来越多介入到知识的生产中，知识与人的需求之间的关系将变得越来越间接，甚至会反过来支配人的需求.

#### 7. 人工智能也对传统的法律法规和社会规范提出了挑战

> 譬如，无人驾驶汽车一旦出现事故，我们究竟该归因于开发产品的企业、产品拥有者还是人工智能产品本身？
![](https://github.com/yangzhanp/yangzhanp----homework/blob/gh-pages/images/u%3D3302937020%2C4211329707%26fm%3D26%26gp%3D0.jpg)

* ——2018-07-13 09:33 
* 来源：经济日报

二、 排序算法举例
=
## 简单的排序算法举例
---
#### 1. 冒泡排序的实例
> 我们暂时以是个事故为准来说明其过程,此处升序排列

```c
#include<stdio.h>
#define max 10

int main(){
    int temp,arr[max] = {9,8,7,6,5,4,3,2,1} //初始化一个降序的数组，把它通过算法实现升序的排列
    for(int i = 0; i < max-1; ++i)
        for(int j = 0; j < max-1; ++j) //运用两层的潜逃循环的母的是，假使最后一个数字是最小的，通过交换也能将它放在最前面
            if(arr[j] < arr[j+1]){ //比较，后面的元素比较小的时候，就交换它们的值
                temp = arr[i];
                arr[i] = arr[i+1];
                arr[i+1] = temp;
            }
}
```
> 如需输出，最后代码的循环外侧再置一个遍历循环输出即可

***概括来说，上面的排序算法，就是把元素先通过内层的循环比较，与相邻位置的实现大小的排序，很明显，这样一次的排序，并不能够保证你的所有数据都以你想的方式输出，事实上也不可能，所以，我们考虑一个比较极端的情况，要是上面说的升序排列的原数组的最后一个数最小，需要这种“相邻交换”九次，因为我们每次，只能将它换一次，毕竟，其余的遍历用来交换其他的值，所以，至少需要（n-1）（n-1）次的交换，也即上面代码的表示，就能完成这个任务***
        
   
    

